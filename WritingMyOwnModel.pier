!! Creating new basic widget

''Spec'' provides for a large amount and wide variety of basic widgets. 
In the rare case that a basic widget is missing, the ''Spec'' framework will need to be extended to add this new widget.
In this section we will explain how to create such a new basic widget.

We will first explain the applicable part of how the widget build process is performed.
This will reveal the different actors in the process and provide a clearer understanding of their responsibilities.
We then present the three steps of widget creation: writing a new model, writing an adapter, and updating or creating an individual UI framework binding.

!!! One step in the building process of a widget

The UI building process does not make a distinction between basic and composed widgets.
Hence, at a specific point in the building process of a basic widget the default spec method of the widget is called, just as if it would be a composed widget.
However in this case, instead of providing a layout for multiple widgets that comprise the UI, this method builds an adapter to the underlying UI framework.
Depending of the underlying UI framework that is currently used, this method can provide different kind of adapters, for example an adapter for Morphic, or an adapter for Seaside, etc.

The adapter, when created, will instantiate a widget that is specific to the UI framework being used.
@@note For Ben: please clarify the 'when created'. Is this when the spec method executes, or at some later point in time?
For example, when using a List in the Morphic UI, the adaptor will be a MorphicListAdapter and it will contain a PluggableListMorph.
This is this framework specific widget which will be returned by the model and rendered.
@@note For Ben: It is not clear when it will be returned, and to who it will be returned, and how this links to it being rendered.

Figure *model_adapter_uielement* shows the relationship between those objects.
@@note For Ben: Model is an instance of Adapter and Adapter is an instance of UI Element? That can not be right ... 

+Relationship between the model, the adapter, and the ui element>file://figures/Model-Adapter-UIElement.png|width=50|label=model_adapter_uielement+

!!! The Model

The new model needs to be a subclass of ""AbstractWidgetModel"" and its name should be composed of the new basic widget concept, e.g. list or button, and of the word ''Model''.
The responsibility of the model is to store all the state of the widget.
Examples of widget-specific state are:
- the index of a list
- the label of a button
- the action block for when a text is validated in a text field

The state is wrapped in value holders and kept in instance variables.
For example, the code in *ex_value_holder* shows how to wrap the state ==0== in a value holder and keep it as an instance variable.
Value holders are needed because they are later used to propagate state changes and thus create the interaction flow of the user interface, as discussed in Section *sec_heart_of_spec*.

[[[label=ex_value_holder|caption=Storing state wrapped in a Value Holder in an instance variable|language=Smalltalk 
index := 0 asValueHolder.
]]]

For each instance variable that holds state three methods should be defined: the getter, the setter, and the registration method.
The first two should classified in the protocol named ''protocol'' while the registration method should be in ''protocol-events''.
For example, the code in *ex_mutators* shows the methods for the example code in *ex_value_holder*. 

[[[label=ex_mutators|caption=Example of mutators for index|language=Smalltalk 
"in protocol: protocol"
index
	^index value

"in protocol: protocol"
index: anInteger
	index value: anInteger

"in protocol: protocol-events"
whenIndexChanged: aBlock
	index whenChangedDo: aBlock
]]]

The last step to define a new model is to implement a method ==adapterName== at class side.
The method should be in the protocol named ''spec'' and should return a symbol.
The symbol should be composed of the basic concept of the widget, e.g. list or button, and the word ''Adapter'' like ""ListAdapter"".

Since the same model can hold the state of different views, like in the MVC pattern, multiple adapters can refer to the same model.
Consequently, the adapter updating logic uses the dependents mechanism.
In fact the message ==change: with: == is used to call the message ''selector'' on the adaptor with the arguments ''aCollection'' to the adapter.
The propagation is done regardless of the number of adapters.

@@note For Ben: I do not understand the above paragraph. Is it there to explain the existence of the ==adapterName== method? This is not clear at all.

!!! The Adapter

@@note For Ben: What is the class of the adaptor? Clarify.

The adapter name should be composed of the UI framework name, e.g. Morphic, and the name of the adapter it is implementing, e.g. ListAdapter.
The adapter is an object used to connect a UI framework specific element and the framework independent model.
The only mandatory method for an adapter is ==defaultSpec== on the class side.

@@note For Ben: What should defaultSpec do? What are its responsibilities? Give an example.

Since the adapter is bridging the gap between the element of the UI framework and the model, the adapter also needs to forward the queries from the UI element to the model.
Seen from the other way around: since the model is holding the state, the adapter is used to update the UI element state of the model.

The methods involved in the communication with the model should be in the protocol ''spec protocol'' while the methods involded in the UI element should be ''widget API''.

@@note For Ben: Rephrase: in the communication FROM the model TO the UI element should be ... and in the communication FROM the UI element TO the model should be ... I am confused which is which.

To communicate with the UI element, the adapter methods uses the method ==widgetDo:==.
This method executes the block provided as argument, which will only happen after the ui element has already been created.

@@note For Ben: An example is needed here. 

!!! The UI Framework binding

The bindings is an object that is used to resolve the name of the adapter at run time.
This allows for the same model to be used with several UI frameworks.

@@note For Ben: What is the class of the bindings (text above)? What is the default adapter (text below)? 

Adding the new adapter to the default adapter is quite simple.
It requires to update two methods: ==initializeBindings== in ""SpecAdapterBindings"" and ==initializeBindings== in the framework specific adapter class, e.g. ""MorphicAdapterBindings"" for Morphic.

@@note For Ben: Give an example here.

Once this is done, the bindings should be re-initialized by running the following snippet of code: ==SpecInterpreter hardResetBindings==.
