!! Spec the Dynamic
@sec_spec_the_dynamic

Having an user interface with a well known number of sub widgets and a static layout is not always sufficient. 
A user interface is often more than just that, for example here are two situations where more is needed: 
First, it happens that the layout of the user interface needs to be changed at runtime to match the execution context of the software.
Second, sub widgets are added or removed at runtime and therefore the programmer need to be able to parametrize those new sub widgets on the fly.

''Spec'' also provides support for such dynamic user interfaces.
In this section we show how to use ''Spec'' in these situations.
First, we talk about making dynamic modifications of the layout of widgets, and second discuss the dynamic adding and removing of subwidgets.
Third and last we show how the dynamic features can be used to quickly prototype a user interface.

!!! Dynamic modification of the layout

Changing the layout of widgets at runtime is straightforward, as we will see here.
Such changes basically consist of three steps:
# creating the new layout,
# setting the required flag to prohibit the creation of a new ui element but to reuse the existing one,
# building the UI again with the newly created layout.

The code in  *rebuildDynamically* is an example of rebuilding a widget with a new layout.
First, a helper method is used to obtain a ==SpecLayout== object that determines the new layout.
Second, the ==needRebuild== flag is set to ==false== to prohibit the creation of a new ui element but to reuse the existing one.
This leads to the replacement of the content of the current container instead of just instantiating a new UI element.
Third, the rebuilding of the user interface is performed.

[[[label=rebuildDynamically|caption=Rebuild a widget at run time|language=Smalltalk 
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false. "tells the interpreter to keep my current ui element"
	self buildWithSpecLayout: newLayout. "rebuilds me with the new layout"
]]]

One widget can also keep the UI elements of its sub widgets which did not need to be rebuilt.
The message ==needRebuild: false== need to be sent to any of those sub widgets.
If a model composing a ''button'' and a ''list'' just want to rearrange the position of the UI elements, there is no need to instantiate new UI elements.
To prevent this, the method ==needRebuild:== can be send to them as shown in the example *ex_needRebuild*.

[[[label=ex_needRebuild|caption=How to need rebuild sub widgets|language=Smalltalk 
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false.
	button needRebuild: false.
	list needRebuild: false.
	self buildWithSpecLayout: newLayout.
]]]

!!! Dynamic adding and removal of subwidgets

If an user interface needs a varying number of subwidgets, the amount of which cannot be established at compilation time, then another approach is needed.
In this scenario, ==DynamicComposableModel== is the model that needs to be subclassed, as this class provides support for the required kind of dynamic behavior.

When using ==DynamicComposableModel== the instantiation of the sub widgets is a bit different from normal use.
In the ==instantiateWidgets== method, instead of instantiating each widget separately, ==instantiateModels:== should be used to instantiate them.
This method takes as argument an array of pairs, where each pair is composed of the unique name of the widget as key, and the name of the widget class as value.
This allows for a widget to be accessed by sending a message whose selector is the widget name to the model.

By example, if a widget named ==button== is created, then this widget can be accessed by calling ==self button== as shown in the example *ex_dynamic_creation*.

[[[label=ex_dynamic_creation|caption=Dynamic creation of a widget|language=Smalltalk 
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

Note that the instantiation array can also be an array of pairs. The previous example could be written

[[[label=ex_dynamic_creation2|caption=Dynamic creation of a widget|language=Smalltalk 
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

!!! Example: Prototyping a UI

Thanks to the capability of ''Spec'' to dynamically instantiate widgets, it is also possible to prototype a user interface from within any workspace.

The example *ex_prototyping* shows how to easily and quickly design a popup window asking for an input.

[[[label=ex_prototyping|caption=Popup requiring a simple input|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
toolbar := OkToolbar new
	okAction: [ regex := view text text ];
	yourself.
	view focusOrder add: view text.
view text bindKeyCombination: Character cr asKeyCombination  toAction: [ toolbar triggerOkAction ].
view label text: 'Packages:'.
view text
	autoAccept: true;
		entryCompletion: nil;
	ghostText: '.*'.
view openDialogWithSpecLayout: (SpecLayout composed
		newRow: [ :r | r add: #label width: 75; add: #text ];
yourself))
	toolbar: toolbar;
	centered;
	modalRelativeTo: World.
]]]

The result can be seen in Figure *fig_popup*.

+Prototype of a popup>file://figures/Popup.png|width=50|label=fig_popup+
