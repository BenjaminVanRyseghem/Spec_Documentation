!! Spec the Dynamic
@sec_spec_the_dynamic

Having an user interface with a well known number of sub widgets and a static layout is not always sufficient. 
A user interface is often more than just that, for example here are two situations where more is needed: 
First, it happens that the layout of the user interface needs to be changed at runtime to match the execution context of the software.
Second, sub widgets are added or removed at runtime and therefore the programmer need to be able to parametrize those new sub widgets on the fly.

''Spec'' also provides support for such dynamic user interfaces.
In this section we show how to use ''Spec'' in these situations.
First, we talk about making dynamic modifications of the layout of widgets, and second discuss the dynamic adding and removing of subwidgets.
Third and last we show how the dynamic features can be used to quickly prototype a user interface.

!!! Dynamic modification of the layout

Changing the layout of widgets at runtime is straightforward, as we will see here.
Such changes basically consist of three steps:
# creating the new layout,
# setting a flag to prohibit the creation of a new UI element (and instead reuse the existing one),
# building the UI again with the newly created layout.

The code in  *rebuildDynamically* is an example of rebuilding a widget with a new layout.
First, a helper method is used to obtain a ==SpecLayout== object that determines the new layout.
Second, the ==needRebuild== flag is set to ==false== such that the existing UI element is reused.
This leads to the replacement of the content of the current container instead of just instantiating a new UI element.
Third, the rebuilding of the user interface is performed.

[[[label=rebuildDynamically|caption=Rebuild a widget at run time|language=Smalltalk 
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false. "tells the interpreter to keep my current UI element"
	self buildWithSpecLayout: newLayout. "rebuilds me with the new layout"
]]]

One widget can also keep the UI elements of its sub widgets which do not need to be rebuilt.
The message ==needRebuild: false== needs to be sent to any of those sub widgets.
If a model comprising a ''button'' and a ''list'' just wants to rearrange the position of these UI elements, there is no need to instantiate new UI elements.
To prevent this, the message ==needRebuild: false== should be send to them, as shown in the example *ex_needRebuild*.

[[[label=ex_needRebuild|caption=How to need rebuild sub widgets|language=Smalltalk 
rebuildWithNewLayout
	| newLayout |

	newLayout := self newLayoutCreatedDynamically.
	self needRebuild: false.
	theButton needRebuild: false.
	theList needRebuild: false.
	self buildWithSpecLayout: newLayout.
]]]

!!! Dynamic adding and removal of subwidgets

If an user interface needs a varying number of subwidgets, the amount of which cannot be established at compilation time, then another approach is needed.
In this scenario, ==DynamicComposableModel== is the model that needs to be subclassed, as this class provides support for the required kind of dynamic behavior.

When using ==DynamicComposableModel== the instantiation of the sub widgets is a bit different from normal use.
In the ==instantiateWidgets== method, instead of instantiating each widget separately, ==instantiateModels:== should be used to instantiate them.
This method takes as argument an array of pairs, where each pair is composed of the unique name of the widget as key, and the name of the widget class as value.
This allows for a widget to be accessed by sending a message whose selector is the widget name to the model.

By example, if a widget named ==button== is created, then this widget can be accessed by calling ==self button== as shown in the example *ex_dynamic_creation*.

[[[label=ex_dynamic_creation|caption=Dynamic creation of a widget|language=Smalltalk 
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

Note that the instantiation array can also be an array of pairs. The previous example could be written

[[[label=ex_dynamic_creation2|caption=Dynamic creation of a widget|language=Smalltalk 
	self instantiateModels: #( button ButtonModel ).
	self button label: 'Click me'.
]]]

@@note For Ben: This section is still a mess with the 2 examples. We should discuss and decide on what to do here.

!!! Example: Prototyping a UI

Thanks to the capability of ''Spec'' to dynamically instantiate widgets, it is also possible to prototype a user interface from within any workspace.

@@note For Ben: Is it possible to divide this code in various snippets and make up a story? Something like: first we try this, then we add this, then we add that, blah.

The example *ex_prototyping* shows how to easily and quickly design a popup window asking for an input.

First we create a simple model with two sub widgets, a label and a text field.

[[[label=label|caption=Create a widget|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	yourself.
]]]

We can then specify the title ans the initiale size of the widget.

[[[label=label|caption=Specify the title ans the initial size|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
]]]

The next step is to set up the sub widgets states and behaviours.
We set the label text as well as the text field ghostText.
We also precise here that the text field should automtically accept the text on each keystroke.

[[[label=label|caption=Set up the sub widgets|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
view label text: 'Packages:'.

view text
	autoAccept: true;
	entryCompletion: nil;
	ghostText: '.*'.
]]]

As we want the widget to be a popup with a single button 'Ok', the toolbar to use should be defined explicitely (the default toolbar has an 'Ok' button and a 'Cancel' button).
We also set the toolbar action when 'Ok' is clicked.
Here the current text of the text field will be saved in the instance variable ''regex''.

[[[label=label|caption=Instantiate the toolbar|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
view label text: 'Packages:'.

view text
	autoAccept: true;
	entryCompletion: nil;
	ghostText: '.*'.
	
toolbar := OkToolbar new
	okAction: [ regex := view text text ];
	yourself.
]]]

We can also add a shortcut to the text field on ''Enter'' to simulate the click on 'Ok'.

[[[label=label|caption=Add a shortcut|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
view label text: 'Packages:'.

view text
	autoAccept: true;
	entryCompletion: nil;
	ghostText: '.*'.
	
toolbar := OkToolbar new
	okAction: [ regex := view text text ];
	yourself.
	
view text 
	bindKeyCombination: Character cr asKeyCombination 
	toAction: [ toolbar triggerOkAction ].
]]]

Then we specify the UI element layout.
It will be only one row with the label and the text field.

[[[label=label|caption=Define the layout|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
view label text: 'Packages:'.

view text
	autoAccept: true;
	entryCompletion: nil;
	ghostText: '.*'.
	
toolbar := OkToolbar new
	okAction: [ regex := view text text ];
	yourself.
	
view text 
	bindKeyCombination: Character cr asKeyCombination 
	toAction: [ toolbar triggerOkAction ].
	
layout := SpecLayout composed
	newRow: [ :r | r add: #label width: 75; add: #text ];
	yourself.
]]]

We finally open the widget.
In addition we specify it will be centered in the Pharo window and modal.

[[[label=label|caption=Open the widget|language=Smalltalk 
view := DynamicComposableModel new
	instantiateModels: #(label LabelModel text TextInputFieldModel);
	extent: 300@90;
	title: 'Choose your project'
	yourself.
	
view label text: 'Packages:'.

view text
	autoAccept: true;
	entryCompletion: nil;
	ghostText: '.*'.
	
toolbar := OkToolbar new
	okAction: [ regex := view text text ];
	yourself.
	
view text 
	bindKeyCombination: Character cr asKeyCombination 
	toAction: [ toolbar triggerOkAction ].
	
layout := SpecLayout composed
	newRow: [ :r | r add: #label width: 75; add: #text ];
	yourself.
	
(view openDialogWithSpecLayout: layout)
	toolbar: toolbar;
	centered;
	modalRelativeTo: World.
]]]

The result can be seen in Figure *fig_popup*.

+Prototype of a popup>file://figures/Popup.png|width=50|label=fig_popup+
file://figures/Popup.png|width=50|label=fig_popup+
